
// A simple Gmsh API demonstration program.
#include <iostream>
#include "Gmsh.h"
#include "GModel.h"
#include "MElement.h"
#include "MVertex.h"


int main(int argc, char **argv)
{
  // Initialization.
  GmshInitialize(argc, argv);
  // Options may be set this way.
  // Output information messages generated by the Gmsh library.
  GmshSetOption("General", "Terminal", 1.);
  // Be verbose (output debug messages).
  GmshSetOption("General", "Verbosity", 99.);
  // Create GModel (the Gmsh library core) instance.
  GModel *m = new GModel;
  // Choices are "Gmsh" and "OCC" if the Gmsh library is compiled with
  // OpenCASCADE. Usually you want to use the "Gmsh" factory.
  m->setFactory("Gmsh");

  // Add vertices. Equivalent .geo directives are
  // cl1 = 0.1;
  // Point(1) = {-1, -1, 0, cl1};
  // Point(2) = {1, -1, 0, cl1};
  // Point(3) = {1, 1, 0, cl1};
  // Point(4) = {-1, 1, 0, cl1};
  // Point(5) = {0, 0, 0, cl1};
  const double cl1 = 0.1;
  GVertex *gv1 = m->addVertex(-1.0, -1.0, 0.0, cl1);
  GVertex *gv2 = m->addVertex(1.0, -1.0, 0.0, cl1);
  GVertex *gv3 = m->addVertex(1.0, 1.0, 0.0, cl1);
  GVertex *gv4 = m->addVertex(-1.0, 1.0, 0.0, cl1);
  GVertex *gv5 = m->addVertex(0.0, 0.0, 0.0, cl1);

  // Add lines. Equivalent .geo directives are
  // Line(1) = {1, 2};
  // Line(2) = {2, 3};
  // Line(3) = {3, 4};
  // Line(4) = {4, 1};
  GEdge *ge1 = m->addLine(gv1, gv2);
  GEdge *ge2 = m->addLine(gv2, gv3);
  GEdge *ge3 = m->addLine(gv3, gv4);
  GEdge *ge4 = m->addLine(gv4, gv1);

  // Add line loop. Equivalent .geo directive is
  // Line Loop(1) = {1, 2, 3, 4};
  // The line loop container is a vector of vectors so that
  // lineLoop1[1] and afterwards (if present) can represent holes in
  // the surface defined by lineLoop1[0], which is an equivalent API
  // representation of Plane Surface(1) = {1, 2}; where line loop 2 in
  // the right hand side represents a hole.
  std::vector<std::vector<GEdge *> > lineLoop1(1);
  lineLoop1[0].push_back(ge1);
  lineLoop1[0].push_back(ge2);
  lineLoop1[0].push_back(ge3);
  lineLoop1[0].push_back(ge4);

  // Add surface. Equivalent .geo directive is
  // Plane Surface(1) = {1};
  GFace *gf1 = m->addPlanarFace(lineLoop1);

  // Add embedded vertex to gf1. Equivalent .geo directive is
  // Point {5} In Surface {1};
  gf1->addEmbeddedVertex(gv5);

  // The geometry constructed by the operations above may be saved this way.
  m->writeGEO("test.geo");

  // Create surface (2-D) mesh. Pass 3 to mesh() if creating a volume
  // (3-D) mesh.
  m->mesh(2);

  // The created mesh may be saved this way.
  m->writeMSH("test.msh");

  // Now that the mesh is created, let's try extracting the mesh
  // information programatically.

  // Index all the mesh vertices in a continuous sequence starting at
  // 1.
  m->indexMeshVertices(true);

  // Get the number of vertices in the mesh
  const int nPoints = m->getNumMeshVertices();
  for(int pointI = 0; pointI < nPoints; ++pointI)
    {
    // Get vertex. Note that the vertex tag number starts at 1.
    MVertex *mv = m->getMeshVertexByTag(pointI + 1);
    // Get vertex coordinates.
    std::cout << mv->x() << " " << mv->y() << " " << mv->z() << std::endl;
    }

  // The mesh elements are obtained by per entity basis. The operations
  // presented here obtains surface elements on surface gf1.
  // Get the number of mesh elements on gf1.
  const int nElements = gf1->getNumMeshElements();
  for(int elemI = 0; elemI < nElements; ++elemI)
    {
    // Get element. Note that the argument given to getMeshElement()
    // starts from 0.
    MElement *me = gf1->getMeshElement(elemI);
    // Get the number of vertices on the element.
    const int nVertices = me->getNumVertices();
    for(int vertI = 0; vertI < nVertices; ++vertI)
      {
      // Get the vertex number. note that the argument given to
      // getVertex() starts from 0. Also, note that the vertex tag
      // number returned by getIndex() starts at 1.
      std::cout << " " << me->getVertex(vertI)->getIndex();
      // One may alternatively get the vertices in VTK ordering by
      // std::cout << " " << me->getVertexVTK(vertI)->getIndex();
      // Note that even with getVertexVTK() the vertex tag number
      // starts at 1.
      }
    std::cout << std::endl;
    }

  // Finalization.
  delete m;
  GmshFinalize();
}